<!DOCTYPE html>
<html>
  <head>
    <title>Transformation matrix interface</title>
    <meta charset='utf-8'>
    <!--<script src='respec-w3c-common.js' class='remove'></script>-->
    <script src="respec/respec.js" class="remove"></script>
    <script src="biblio.js" class="remove"></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "MO",
          shortName:            "matrix",
          edDraftURI:           "https://dvcs.w3.org/hg/FXTF/raw-file/default/matrix/index.html",
          editors:  [
              { name: "Dirk Schulze", mailto: "dschulze@adobe.com",
                company: "Adobe Systems Inc.", companyURL: "http://adobe.com/" },
          ],
          extraCSS: ["respec/respec.css",
                     "matrix.css"],
          // Turning off inlineCSS for now since if extraCSS points to
          // a relative URL your testing from a file URL the XHR will fail.
          // Probably should turn this back on once this is hosted on a server
          // somewhere.
          inlineCSS: false,
          wg: [ "CSS Working Group",
                "SVG Working Group" ],
          wgURI: [ "http://dev.w3.org/Style/CSS/members",
                   "http://www.w3.org/Graphics/SVG/WG" ],

          wgActivity: [ 
            [ "Style",    "http://www.w3.org/Style/Activity" ],
            [ "Graphics", "http://www.w3.org/Graphics/Activity" ]
          ],          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-fx",
          wgPatentURI:  "",
          noIDLIn:  true,
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification describes a transformation matrix interface with the dimension of 3x2 and 4x4.
      </p>

      <p>
        The transformation matrix interface replaces the SVGMatrix interface from SVG [[SVG11]]. It is a common interface used to describe 2D and 3D transformations on a graphical context for SVG, Context2D [[CANVAS-2D]], CSS3 Transforms [[CSS3-TRANSFORMS]] and WebGL [[WEBGL]].
      </p>
    </section>

    <section>
      <h2>Definitions</h2>
      <dl>
        <dt><dfn>Post-multiply</dfn></dt>
        <dd>Matrix or point B post-multiplied to matrix or point A is equal to A &middot; B.</dd>
        <dt><dfn>Pre-multiply</dfn></dt>
        <dd>Matrix or point B pre-multiplied to matrix or point A is equal to B &middot; A.</dd>
        <dt><dfn>Multiply</dfn></dt>
        <dd>Multiply matrix or pointy B with matrix or point A is equal to <a>post-multiply</a> matrix or point B with matrix or point A.</dd>
      </dl>
    </section>

    <section>
      <h2>The <a>Point</a> dictionary</h2>
      <p>
        A 2D points and 3D points are represented by the following WebIDL dictionary:
      </p>

      <dl title='dictionary Point' class='idl'>
        <dt>double x = 0</dt>
        <dd>
          The x coordinate of the point.
        </dd>
        <dt>double y = 0</dt>
        <dd>
          The y coordinate of the point.
        </dd>
        <dt>double z = 0</dt>
        <dd>
          The z coordinate of the point.
        </dd>
        <dt>double w = 1</dt>
        <dd>
          The perspective of the point.
          <p class='issue'>
            A multiplication of a point with a matrix requires 4 values. Implementations usually normalize the point by w. It should be considered to do this here as well.
          </p>
        </dd>
      </dl>
    </section>

    <section>
      <h2>The <a>DecomposedMatrix</a> dictionary</h2>
      <p>
        The resulting values of a decomposed matrix as defined by <a href="#decomposing-the-matrix">Decomposing the matrix</a> and used in CSS Transforms [[CSS3-TRANSFORMS]] are represented by the following DecomposedMatrix dictionary:
      </p>

      <dl title='dictionary DecomposedMatrix' class='idl'>
        <dt>sequence&lt;double> translation</dt>
        <dd>
          Is an sequence of three double items for the translation of the matrix.
        </dd>
        <dt>sequence&lt;double> scale</dt>
        <dd>
          Is an sequence of three double items for the scaling of the matrix.
        </dd>
        <dt>sequence&lt;double> skew</dt>
        <dd>
          Is an sequence of three double items representing the shear of the matrix.
        </dd>
        <dt>sequence&lt;double> perspective</dt>
        <dd>
          Is an sequence of four double items representing the perspective of the matrix.
        </dd>
        <dt>sequence&lt;double> quaternions</dt>
        <dd>
          Is an sequence of four double items representing the two quaternions for the rotation of the matrix.
        </dd>
      </dl>

      <p class='issue'>
        It is doubtful that this can be very useful for authors. On the other hand, it allows scripted animations similar to the animations by CSS3 Transforms.
      </p>
    </section>

    <section>
      <h2>The <a>Matrix</a> interface</h2>

      <p>
        The <a>Matrix</a> interface represents a mathematical matrix with the purpose of describing transformations a graphical contexts. The following sections describe the details of the interface. For the full interface see <a href="#webidl-ref">Interface summary</a>.
      </p>

      <section>
        <h3>The constructors</h3>

        <p>
          A series of constructors to create a <a>Matrix</a> object.
        </p>

        <dl title='interface Matrix' class='idl'>
          <dt>Constructor()</dt>
          <dd>Creates an identity matrix.</dd>
          <dt>Constructor()</dt>
          <dd>
            <dl class='parameters'>
              <dt>DOMString transformList</dt>
              <dd>A DOMString of transformation functions with the syntax and specifies defined in CSS Transforms [[!CSS3-TRANSFORMS]]. One CSS pixel length maps to one unit less value in the matrix.</dd>
            </dl>
            The DOMString must consist of a transform function list as specified by CSS Transforms.
            <div class='example'>
              <pre><code>var matrix = new Matrix("translate(20px,20px), scale(2,3), rotate(45deg)"</code></pre>
            </div>
            <p class='issue'>Should it be postponed to avoid CSS3 Transforms dependency?</p>
          </dd>
          <dt>Constructor()</dt>
          <dd>
            <dl class='parameters'>
              <dt>Matrix other</dt>
              <dd>All element values of the current matrix are set to the element values of the other matrix.</dd>
            </dl>
          </dd>
          <dt>Constructor()</dt>
          <dd>
            <dl class='parameters'>
              <dt>DecomposedMatrix decomposedValues</dt>
              <dd>
                Recomposes the decomposed values as specified in <a href="#recomposing-the-matrix">Recomposing the matrix</a> and sets the element values of the current matrix.
              </dd>
            </dl>
          </dd>
          <dt>Constructor()</dt>
          <dd>
            <dl class='parameters'>
              <dt>Float32array array</dt>
              <dd>
                Create an identity matrix first. An array of 6 items sets the element values <code>a</code> to <code>f</code>. An array of 16 items sets the element values <code>m11</code> to <code>m44</code>.
              </dd>
            </dl>
          </dd>
          <dt>Constructor()</dt>
          <dd>
            <dl class='parameters'>
              <dt>sequence&lt;double> numberSequence</dt>
              <dd>
                Create an identity matrix first. A sequence of 6 items sets the element values <code>a</code> to <code>f</code>. A sequence of 16 items sets the element values <code>m11</code> to <code>m44</code>. 
              </dd>
            </dl>
          </dd>
        </section>

        <section>
          <h3>Two-dimensional attributes</h3>

          <p>
            If a <a>Matrix</a> just consists of 2D transformations the 6 values <code>a</code> to <code>f</code> can represent the transformation matrix. If the <a>Matrix</a> object is immutable, a DOMException of type <code>NoModificationAllowedError</code> must be thrown on setting the attributes.
          </p>

          <p>
            The following attributes <code>a</code> to <code>f</code> are aliases to the two-dimensional elements of the 4x4 matrix.
          </p>

          <dl title='partial interface Matrix' class='idl'>
            <dt>// These attributes are simple aliases for certain elements of the 4x4 matrix</dt>
            <dd></dd>
            <dt>attribute double a</dt>
            <dd>
              <p>Corresponds to the attribute <span>m11</span> of the Matrix interface.</p>
            </dd>
            <dt>attribute double b</dt>
            <dd>
              <p>Corresponds to the attribute <span>m12</span> of the Matrix interface.</p>
            </dd>
            <dt>attribute double c</dt>
            <dd>
              <p>Corresponds to the attribute <span>m21</span> of the Matrix interface.</p>
            </dd>
            <dt>attribute double d</dt>
            <dd>
              <p>Corresponds to the attribute <span>m22</span> of the Matrix interface.</p>
            </dd>
            <dt>attribute double e</dt>
            <dd>
              <p>Corresponds to the attribute <span>m41</span> of the Matrix interface.</p>
            </dd>
            <dt>attribute double f</dt>
            <dd>
              <p>Corresponds to the attribute <span>m42</span> of the Matrix interface.</p>
            </dd>
          </dl>
        </section>

        <section>
          <h3>Three-dimensional attributes</h3>

          <p>
            The following attributes <code>m11</code> to <code>m44</code> represent the elements of the 4x4 matrix. The coordinates are in column-major order. If the <a>Matrix</a> object is immutable, a DOMException of type <code>NoModificationAllowedError</code> must be thrown on setting the attributes.
          </p>

          <dl title='partial interface Matrix' class='idl'>
            <dt>attribute double m11</dt>
            <dd>
              <p>
                The value of the element in column 1, row 1 of the matrix.
              </p>
            </dd>
            <dt>attribute double m12</dt>
            <dd>
              <p>
                The value of the element in column 1, row 2 of the matrix.
              </p>
            </dd>
            <dt>attribute double m13</dt>
            <dd>
              <p>
                The value of the element in column 1, row 3 of the matrix.
              </p>
            </dd>
            <dt>attribute double m14</dt>
            <dd>
              <p>
                The value of the element in column 1, row 4 of the matrix.
              </p>
            </dd>
            <dt>attribute double m21</dt>
            <dd>
              <p>
                The value of the element in column 2, row 1 of the matrix.
              </p>
            </dd>
            <dt>attribute double m22</dt>
            <dd>
              <p>
                The value of the element in column 2, row 2 of the matrix.
              </p>
            </dd>
            <dt>attribute double m23</dt>
            <dd>
              <p>
                The value of the element in column 2, row 3 of the matrix.
              </p>
            </dd>
            <dt>attribute double m24</dt>
            <dd>
              <p>
                The value of the element in column 2, row 4 of the matrix.
              </p>
            </dd>
            <dt>attribute double m31</dt>
            <dd>
              <p>
                The value of the element in column 3, row 1 of the matrix.
              </p>
            </dd>
            <dt>attribute double m32</dt>
            <dd>
              <p>
                The value of the element in column 3, row 2 of the matrix.
              </p>
            </dd>
            <dt>attribute double m33</dt>
            <dd>
              <p>
                The value of the element in column 3, row 3 of the matrix.
              </p>
            </dd>
            <dt>attribute double m34</dt>
            <dd>
              <p>
                The value of the element in column 3, row 4 of the matrix.
              </p>
            </dd>
            <dt>attribute double m41</dt>
            <dd>
              <p>
                The value of the element in column 4, row 1 of the matrix.
              </p>
            </dd>
            <dt>attribute double m42</dt>
            <dd>
              <p>
                The value of the element in column 4, row 2 of the matrix.
              </p>
            </dd>
            <dt>attribute double m43</dt>
            <dd>
              <p>
                The value of the element in column 4, row 3 of the matrix.
              </p>
            </dd>
            <dt>attribute double m44</dt>
            <dd>
              <p>
                The value of the element in column 4, row 4 of the matrix.
              </p>
            </dd>
          </dl>
        </section>

        <section>
          <h3>Immutable transformation methods</h3>

          <p>
            The following methods do not modify the current matrix and return new <a>Matrix</a> object.
          </p>

          <dl title='partial interface Matrix' class='idl'>
            <dt>// Immutable transform methods</dt>
            <dd></dd>
            <dt>Matrix translate()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double tx</dt>
                <dd>Translation value along the x-axis.</dd>
                <dt>double ty</dt>
                <dd>Translation value along the y-axis.</dd>
                <dt>optional double tz = 0</dt>
                <dd>Optional translation value along the z-axis.</dd>
              </dl>
              Post-multiplies a translation transformation on the current matrix and returns the resulting matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix scale()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double scale</dt>
                <dd>Multiplier for a uniform scale transformation.</dd>
                <dt>optional double x</dt>
                <dd>Transformation origin on the x-axis. Defaulting to 0.</dd>
                <dt>optional double y</dt>
                <dd>Transformation origin on the y-axis. Defaulting to 0.</dd>
              </dl>
              Post-multiplies a uniform 2D scale transformation (<code>m11 = m22 = scale</code>) on the current matrix with the given origin and returns the resulting matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix scale3d()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double scale</dt>
                <dd>Multiplier for a uniform scale transformation.</dd>
                <dt>optional double x</dt>
                <dd>Transformation origin on the x-axis. Defaulting to 0.</dd>
                <dt>optional double y</dt>
                <dd>Transformation origin on the y-axis. Defaulting to 0.</dd>
                <dt>optional double z</dt>
                <dd>Transformation origin on the z-axis. Defaulting to 0.</dd>
              </dl>
              Post-multiplies a uniform scale transformation (<code>m11 = m22 = m33 = scale</code>) on the current matrix with the given origin and returns the resulting matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix scaleNonUniform()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double scaleX</dt>
                <dd>Multiplier for a non-uniform scale along the x-axis.</dd>
                <dt>optional double scaleY</dt>
                <dd>Multiplier for a non-uniform scale along the y-axis. Defaulting to 1.</dd>
                <dt>optional double scaleZ</dt>
                <dd>Multiplier for a non-uniform scale along the z-axis. Defaulting to 1.</dd>
                <dt>optional double x</dt>
                <dd>Transformation origin on the x-axis. Defaulting to 0.</dd>
                <dt>optional double y</dt>
                <dd>Transformation origin on the y-axis. Defaulting to 0.</dd>
                <dt>optional double z</dt>
                <dd>Transformation origin on the z-axis. Defaulting to 0.</dd>
              </dl>
              Post-multiplies a non-uniform scale transformation on the current matrix with the given origin and returns the resulting matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix rotate()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double angle</dt>
                <dd>Rotation angle in degrees.</dd>
                <dt>optional double x</dt>
                <dd>Transformation origin on the x-axis. Defaulting to 0.</dd>
                <dt>optional double y</dt>
                <dd>Transformation origin on the y-axis. Defaulting to 0.</dd>
                <dt>optional double z</dt>
                <dd>Transformation origin on the z-axis. Defaulting to 0.</dd>
              </dl>
              Post-multiplies a rotation transformation on the current matrix with the given origin and returns the resulting matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix rotateFromVector(double x, double y)</dt>
            <dd>
              <dl class='parameters'>
                <dt>double x</dt>
                <dd>The x coordinate of the vector (x,y). Must not be zero.</dd>
                <dt>double y</dt>
                <dd>The y coordinate of the vector (x,y). Must not be zero.</dd>
              </dl>
              Post-multiplies a rotation transformation on the current matrix and returns the resulting matrix. The rotation angle is determined by taking (+/-) atan(y/x). The direction of the vector (x, y) determines whether the positive or negative angle value is used. The current matrix is not modified.
              <p class='issue'>Is there a need for a 3D rotation?</p>
            </dd>
            <dt>Matrix rotateAxisAngle(double x, double y, double z, double angle)</dt>
            <dd>
              <dl class='parameters'>
                <dt>double x</dt>
                <dd>The x coordinate of the vector (x,y,z).</dd>
                <dt>double y</dt>
                <dd>The y coordinate of the vector (x,y,z).</dd>
                <dt>double z</dt>
                <dd>The z coordinate of the vector (x,y,z).</dd>
                <dt>double angle</dt>
                <dd>Rotation angle in degrees.</dd>
                Post-multiplies a rotation transformation on the current matrix and returns the resulting matrix. The rotation of the transform is applied around the given vector. The current matrix is not modified.
              </dl>
            </dd>
            <dt>Matrix skewX()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double sx</dt>
                <dd>Skew angle along the x-axis in degrees.</dd>
              </dl>
              Post-multiplies a skewX transformation on the current matrix and returns the resulting matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix skewY()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double sy</dt>
                <dd>Skew angle along the y-axis in degrees.</dd>
              </dl>
              Post-multiplies a skewX transformation on the current matrix and returns the resulting matrix.
            </dd>
            <dt>Matrix multiply()</dt>
            <dd>
              <dl class='parameters'>
                <dt>Matrix other</dt>
                <dd>Other matrix for multiplication</dd>
              </dl>
              Performs matrix multiplication. This matrix is post-multiplied by the other matrix, returning the resulting new matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix flipX()</dt>
            <dd>
              Post-multiplies the transformation <code>Matrix(-1, 0, 0, 1, 0, 0)</code> and returns the resulting matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix flipY()</dt>
            <dd>
              Post-multiplies the transformation <code>Matrix(1, 0, 0, -1, 0, 0)</code> and returns the resulting matrix. The current matrix is not modified.
            </dd>
            <dt>Matrix? inverse()</dt>
            <dd>
              Returns the inverted matrix of the current matrix if applicable. Otherwise <code>null</code>. The current matrix is not modified.
              <dl class='exceptions'>
                <dt>DOMException of type
                    <code>InvalidModificationError</code></dt>
                <dd>
                  Raised when the current matrix is singular.
                </dd>
              </dl>
            </dd>
          </dl>
        </section>

        <section>
          <h3>Mutable transformation methods</h3>

          <p>
            The following methods do modify the current matrix. If the <a>Matrix</a> object is immutable, a DOMException of type <code>NoModificationAllowedError</code> must be thrown on calling the operations below.
          </p>

          <dl title='partial interface Matrix' class='idl'>
            <dt>// Mutable transform methods</dt>
            <dd></dd>
            <dt>void multiplyBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>Matrix other</dt>
                <dd>The matrix that gets post-multiplied.</dd>
              </dl>
              The other matrix gets post-multiplied to the current matrix.
            </dd>
            <dt>void preMultiplyBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>Matrix other</dt>
                <dd>The matrix that gets pre-multiplied.</dd>
              </dl>
              The other matrix gets pre-multiplied to the current matrix.
            </dd>
            <dt>void translateBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double tx</dt>
                <dd>Translation value along the x-axis.</dd>
                <dt>double ty</dt>
                <dd>Translation value along the y-axis.</dd>
                <dt>optional double tz = 0</dt>
                <dd>Optional translation value along the z-axis.</dd>
              </dl>
              Post-multiplies a translation transformation on the current matrix.
            </dd>
            <dt>void scaleBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double scale</dt>
                <dd>Multiplier for a uniform scale transformation.</dd>
                <dt>optional double x</dt>
                <dd>Transformation origin on the x-axis. Defaulting to 0.</dd>
                <dt>optional double y</dt>
                <dd>Transformation origin on the y-axis. Defaulting to 0.</dd>
              </dl>
              Post-multiplies a uniform 2D scale transformation (<code>m11 = m22 = scale</code>) on the current matrix with the given origin.
            </dd>
            <dt>void scale3dBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double scale</dt>
                <dd>Multiplier for a uniform scale transformation.</dd>
                <dt>optional double x</dt>
                <dd>Transformation origin on the x-axis. Defaulting to 0.</dd>
                <dt>optional double y</dt>
                <dd>Transformation origin on the y-axis. Defaulting to 0.</dd>
                <dt>optional double z</dt>
                <dd>Transformation origin on the z-axis. Defaulting to 0.</dd>
              </dl>
              Post-multiplies a uniform 2D scale transformation (<code>m11 = m22 = m33 = scale</code>) on the current matrix with the given origin.
            </dd>
            <dt>void scaleNonUniformBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double scaleX</dt>
                <dd>Multiplier for a non-uniform scale along the x-axis.</dd>
                <dt>optional double scaleY</dt>
                <dd>Multiplier for a non-uniform scale along the y-axis. Defaulting to 1.</dd>
                <dt>optional double scaleZ</dt>
                <dd>Multiplier for a non-uniform scale along the z-axis. Defaulting to 1.</dd>
                <dt>optional double x</dt>
                <dd>Transformation origin on the x-axis. Defaulting to 0.</dd>
                <dt>optional double y</dt>
                <dd>Transformation origin on the y-axis. Defaulting to 0.</dd>
                <dt>optional double z</dt>
                <dd>Transformation origin on the z-axis. Defaulting to 0.</dd>
              </dl>
              Post-multiplies a non-uniform scale transformation on the current matrix with the given origin.
            </dd>
            <dt>void rotateBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double angle</dt>
                <dd>Rotation angle in degrees.</dd>
                <dt>optional double x</dt>
                <dd>Transformation origin on the x-axis. Defaulting to 0.</dd>
                <dt>optional double y</dt>
                <dd>Transformation origin on the y-axis. Defaulting to 0.</dd>
                <dt>optional double z</dt>
                <dd>Transformation origin on the z-axis. Defaulting to 0.</dd>
              </dl>
              Post-multiplies a rotation transformation on the current matrix with the given origin.
            </dd>
            <dt>void rotateFromVectorBy(double x, double y)</dt>
            <dd>
              <dl class='parameters'>
                <dt>double x</dt>
                <dd>The x coordinate of the vector (x,y). Must not be zero.</dd>
                <dt>double y</dt>
                <dd>The y coordinate of the vector (x,y). Must not be zero.</dd>
              </dl>
              Post-multiplies a rotation transformation on the current matrix. The rotation angle is determined by taking (+/-) atan(y/x). The direction of the vector (x, y) determines whether the positive or negative angle value is used.
              <p class='issue'>Is there a need for a 3D rotation?</p>
            </dd>
            <dt>void rotateAxisAngleBy(double x, double y, double z, double angle)</dt>
            <dd>
              <dl class='parameters'>
                <dt>double x</dt>
                <dd>The x coordinate of the vector (x,y,z).</dd>
                <dt>double y</dt>
                <dd>The y coordinate of the vector (x,y,z).</dd>
                <dt>double z</dt>
                <dd>The z coordinate of the vector (x,y,z).</dd>
                <dt>double angle</dt>
                <dd>Rotation angle in degrees.</dd>
                Post-multiplies a rotation transformation on the current matrix. The rotation of the transform is applied around the given vector.
              </dl>
            </dd>
            <dt>void skewXBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double sx</dt>
                <dd>Skew angle along the x-axis in degrees.</dd>
              </dl>
              Post-multiplies a skewX transformation on the current matrix.
            </dd>
            <dt>void skewYBy()</dt>
            <dd>
              <dl class='parameters'>
                <dt>double sy</dt>
                <dd>Skew angle along the y-axis in degrees.</dd>
              </dl>
              Post-multiplies a skewX transformation on the current matrix.
            </dd>
            <dt>void invert()</dt>
            <dd>
              Inverts the current matrix.
              <dl class='exceptions'>
                <dt>DOMException of type
                    <code>InvalidModificationError</code></dt>
                <dd>
                  Raised when the current matrix is singular.
                </dd>
              </dl>
            </dd>
          </dl>
        </section>

        <section>
          <h3>Helper methods</h3>

          <p>
            The following helper methods do not modify the <a>Matrix</a> object.
          </p>

          <dl title='partial interface Matrix' class='idl'>
            <dt>// Helper methods</dt>
            <dd></dd>
            <dt>boolean is2D()</dt>
            <dd>
              Returns <code>true</code> if <code>m13</code>, <code>m14</code>, <code>m23</code>, <code>m24</code>, <code>m31</code>, <code>m32</code>, <code>m34</code>, <code>m43</code> are equal to zero and <code>m33</code>, <code>m44</code> are equal to one.
            </dd>
            <dt>double determinant()</dt>
            <dd>
              Returns the determinant of the current matrix.
            </dd>
            <dt>Point transformPoint()</dt>
            <dd>
              <dl class='parameters'>
                <dt>Point point</dt>
                <dd>A Point dictionary.</dd>
              </dl>
              The point is post-multiplied on the current matrix and returns the resulting point. <code>point</code> is not modified.
            </dd>
            <dt>Float32Array toFloat32Array()</dt>
            <dd>
              Returns the serialized elements of the current matrix in column-major order as Float32Array.
            </dd>
            <dt>DecomposedMatrix decompose()</dt>
            <dd>
              Returns the decomposed matrix values of the current matrix as a DecomposedMatrix dictionary. The decomposing follows the algorithm of <a href="#decomposing-the-matrix">Decomposing the Matrix</a>.
            </dd>
            <dt>void stringifier()</dt>
            <dd>
              Returns a string in the form of a CSS Transforms <code>matrix</code> function if the current matrix is a 2D transform or a CSS Transforms <code>matrix3d</code> else.
              <p class='issue'>Should be <code>stringifier;</code>. Bug in old respec tool.</p>
            </dd>
          </dl>
      </section>
    </section>

    <section>
      <h2>Decomposing the Matrix</h2>

      <p>
        The pseudocode below is based upon the "unmatrix" method in "Graphics Gems II,
        edited by Jim Arvo", but modified to use Quaternions instead of Euler angles to
        avoid the problem of Gimbal Locks.
      </p>
      
      <p>
        The following pseudocode works on a 4x4 homogeneous matrix:
      </p>

      <pre>Input:  matrix      ; a 4x4 matrix
Output: translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Returns false if the matrix cannot be decomposed, true if it can

Supporting functions (point is a 3 component vector, matrix is a 4x4 matrix):
  double  determinant(matrix)          returns the 4x4 determinant of the matrix
  matrix  inverse(matrix)              returns the inverse of the passed matrix
  matrix  transpose(matrix)            returns the transpose of the passed matrix
  point   multVecMatrix(point, matrix) multiplies the passed point by the passed matrix
                                       and returns the transformed point
  double  length(point)                returns the length of the passed vector
  point   normalize(point)             normalizes the length of the passed point to 1
  double  dot(point, point)            returns the dot product of the passed points
  double  sqrt(double)                 returns the root square of passed value
  double  max(double y, double x)      returns the bigger value of the two passed values

Decomposition also makes use of the following function:
  point combine(point a, point b, double ascl, double bscl)
      result[0] = (ascl * a[0]) + (bscl * b[0])
      result[1] = (ascl * a[1]) + (bscl * b[1])
      result[2] = (ascl * a[2]) + (bscl * b[2])
      return result

// Normalize the matrix.
if (matrix[3][3] == 0)
    return false

for (i = 0; i < 4; i++)
    for (j = 0; j < 4; j++)
        matrix[i][j] /= matrix[3][3]

// perspectiveMatrix is used to solve for perspective, but it also provides
// an easy way to test for singularity of the upper 3x3 component.
perspectiveMatrix = matrix

for (i = 0; i < 3; i++)
    perspectiveMatrix[i][3] = 0

perspectiveMatrix[3][3] = 1

if (determinant(perspectiveMatrix) == 0)
    return false

// First, isolate perspective.
if (matrix[0][3] != 0 || matrix[1][3] != 0 || matrix[2][3] != 0)
    // rightHandSide is the right hand side of the equation.
    rightHandSide[0] = matrix[0][3];
    rightHandSide[1] = matrix[1][3];
    rightHandSide[2] = matrix[2][3];
    rightHandSide[3] = matrix[3][3];

    // Solve the equation by inverting perspectiveMatrix and multiplying
    // rightHandSide by the inverse.
    inversePerspectiveMatrix = inverse(perspectiveMatrix)
    transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix)
    perspective = multVecMatrix(rightHandSide, transposedInversePerspectiveMatrix)
else
    // No perspective.
    perspective[0] = perspective[1] = perspective[2] = 0
    perspective[3] = 1

// Next take care of translation
for (i = 0; i < 3; i++)
    translate[i] = matrix[3][i]

// Now get scale and shear. 'row' is a 3 element array of 3 component vectors
for (i = 0; i < 3; i++)
    row[i][0] = matrix[i][0]
    row[i][1] = matrix[i][1]
    row[i][2] = matrix[i][2]

// Compute X scale factor and normalize first row.
scale[0] = length(row[0])
row[0] = normalize(row[0])

// Compute XY shear factor and make 2nd row orthogonal to 1st.
skew[0] = dot(row[0], row[1])
row[1] = combine(row[1], row[0], 1.0, -skew[0])

// Now, compute Y scale and normalize 2nd row.
scale[1] = length(row[1])
row[1] = normalize(row[1])
skew[0] /= scale[1];

// Compute XZ and YZ shears, orthogonalize 3rd row
skew[1] = dot(row[0], row[2])
row[2] = combine(row[2], row[0], 1.0, -skew[1])
skew[2] = dot(row[1], row[2])
row[2] = combine(row[2], row[1], 1.0, -skew[2])

// Next, get Z scale and normalize 3rd row.
scale[2] = length(row[2])
row[2] = normalize(row[2])
skew[1] /= scale[2]
skew[2] /= scale[2]

// At this point, the matrix (in rows) is orthonormal.
// Check for a coordinate system flip.  If the determinant
// is -1, then negate the matrix and the scaling factors.
pdum3 = cross(row[1], row[2])
if (dot(row[0], pdum3) < 0)
    for (i = 0; i < 3; i++)
        scale[i] *= -1;
        row[i][0] *= -1
        row[i][1] *= -1
        row[i][2] *= -1

// Now, get the rotations out
quaternion[0] = 0.5 * sqrt(max(1 + row[0][0] - row[1][1] - row[2][2], 0))
quaternion[1] = 0.5 * sqrt(max(1 - row[0][0] + row[1][1] - row[2][2], 0))
quaternion[2] = 0.5 * sqrt(max(1 - row[0][0] - row[1][1] + row[2][2], 0))
quaternion[3] = 0.5 * sqrt(max(1 + row[0][0] + row[1][1] + row[2][2], 0))

if (row[2][1] > row[1][2])
    quaternion[0] = -quaternion[0]
if (row[0][2] > row[2][0])
    quaternion[1] = -quaternion[1]
if (row[1][0] > row[0][1])
    quaternion[2] = -quaternion[2]

return true</pre>
    </section>

    <section>
      <h2>Recomposing the Matrix</h2>

      <p>
        After interpolation the resulting values are used to transform the elements user
        space. One way to use these values is to recompose them into a 4x4 matrix. This can
        be done following the pseudo-code below:
      </p>

      <pre>Input:  translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Output: matrix      ; a 4x4 matrix

Supporting functions (matrix is a 4x4 matrix):
  matrix  multiply(matrix a, matrix b)   returns the 4x4 matrix product of a * b  

// apply perspective
for (i = 0; i < 4; i++)
  matrix[i][3] = perspective[i]

// apply translation
for (i = 0; i < 3; i++)
  for (j = 0; j < 3; j++)
    matrix[3][i] += translation[j] * matrix[j][i]

// apply rotation
x = quaternion[0]
y = quaternion[1]
z = quaternion[2]
w = quaternion[3]

// Construct a composite rotation matrix from the quaternion values
// rotationMatrix is a identity 4x4 matrix initially
rotationMatrix[0][0] = 1 - 2 * (y * y + z * z)
rotationMatrix[0][1] = 2 * (x * y - z * w)
rotationMatrix[0][2] = 2 * (x * z + y * w)
rotationMatrix[1][0] = 2 * (x * y + z * w)
rotationMatrix[1][1] = 1 - 2 * (x * x + z * z)
rotationMatrix[1][2] = 2 * (y * z - x * w)
rotationMatrix[2][0] = 2 * (x * z - y * w)
rotationMatrix[2][1] = 2 * (y * z + x * w)
rotationMatrix[2][2] = 1 - 2 * (x * x + y * y)

matrix = multiply(matrix, rotationMatrix)

// apply skew
// temp is a identity 4x4 matrix initially
if (skew[2])
    temp[2][1] = skew[2]
    matrix = multiply(matrix, temp)

if (skew[1])
    temp[2][1] = 0
    temp[2][0] = skew[1]
    matrix = multiply(matrix, temp)

if (skew[0])
    temp[2][0] = 0
    temp[1][0] = skew[0]
    matrix = multiply(matrix, temp)

// apply scale
for (i = 0; i < 3; i++)
  for (j = 0; j < 3; j++)
    matrix[i][j] *= scale[i]

return</pre>
    </section>

    <section class='appendix' id="webidl-ref">
      <h2>Interface summary</h2>
    </section>

    <section class='appendix'>
      <h2>Acknowledgments</h2>
      <p>
        Many thanks to Dean Jackson for his initial proposal to make this specification possible.
      </p>
    </section>
  </body>
</html>
